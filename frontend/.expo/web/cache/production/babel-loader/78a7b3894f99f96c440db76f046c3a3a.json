{"ast":null,"code":"import{LABEL_PADDING_HORIZONTAL,ADORNMENT_OFFSET,ADORNMENT_SIZE,FLAT_INPUT_OFFSET}from\"./constants\";import{AdornmentType,AdornmentSide}from\"./Adornment/enums\";export var calculateLabelTopPosition=function calculateLabelTopPosition(labelHeight){var height=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var optionalPadding=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;var customHeight=height>0?height:0;return Math.floor((customHeight-labelHeight)/2+optionalPadding);};export var calculateInputHeight=function calculateInputHeight(labelHeight){var height=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var minHeight=arguments.length>2?arguments[2]:undefined;var finalHeight=height>0?height:labelHeight;if(height>0)return height;return finalHeight<minHeight?minHeight:finalHeight;};export var calculatePadding=function calculatePadding(props){var height=props.height,_props$multiline=props.multiline,multiline=_props$multiline===void 0?false:_props$multiline;var result=0;if(multiline){if(height&&multiline){result=calculateTextAreaPadding(props);}else{result=calculateInputPadding(props);}}return Math.max(0,result);};var calculateTextAreaPadding=function calculateTextAreaPadding(props){var dense=props.dense;return dense?10:20;};var calculateInputPadding=function calculateInputPadding(_ref){var topPosition=_ref.topPosition,fontSize=_ref.fontSize,multiline=_ref.multiline,scale=_ref.scale,dense=_ref.dense,offset=_ref.offset,isAndroid=_ref.isAndroid;var refFontSize=scale*fontSize;var result=Math.floor(topPosition/2);result=result+Math.floor((refFontSize-fontSize)/2)-(scale<1?offset/2:0);if(multiline&&isAndroid)result=Math.min(dense?offset/2:offset,result);return result;};export var adjustPaddingOut=function adjustPaddingOut(_ref2){var pad=_ref2.pad,multiline=_ref2.multiline,label=_ref2.label,scale=_ref2.scale,height=_ref2.height,fontSize=_ref2.fontSize,lineHeight=_ref2.lineHeight,dense=_ref2.dense,offset=_ref2.offset,isAndroid=_ref2.isAndroid;var fontHeight=lineHeight!==null&&lineHeight!==void 0?lineHeight:fontSize;var refFontHeight=scale*fontSize;var result=pad;if(height&&!multiline){return{paddingTop:Math.max(0,(height-fontHeight)/2),paddingBottom:Math.max(0,(height-fontHeight)/2)};}if(!isAndroid&&multiline){if(dense){if(label){result+=scale<1?Math.min(offset,refFontHeight/2*scale):0;}else{result+=0;}}if(!dense){if(label){result+=scale<1?Math.min(offset,refFontHeight*scale):Math.min(offset/2,refFontHeight*scale);}else{result+=scale<1?Math.min(offset/2,refFontHeight*scale):0;}}result=Math.floor(result);}return{paddingTop:result,paddingBottom:result};};export var adjustPaddingFlat=function adjustPaddingFlat(_ref3){var pad=_ref3.pad,scale=_ref3.scale,multiline=_ref3.multiline,label=_ref3.label,height=_ref3.height,offset=_ref3.offset,dense=_ref3.dense,fontSize=_ref3.fontSize,isAndroid=_ref3.isAndroid,styles=_ref3.styles;var result=pad;var topResult=result;var bottomResult=result;var paddingTop=styles.paddingTop,paddingBottom=styles.paddingBottom;var refFontSize=scale*fontSize;if(!multiline){if(label){return{paddingTop:paddingTop,paddingBottom:paddingBottom};}return{paddingTop:result,paddingBottom:result};}if(label){topResult=paddingTop;bottomResult=paddingBottom;if(!isAndroid){if(dense){topResult+=scale<1?Math.min(result,refFontSize*scale)-result/2:Math.min(result,refFontSize*scale)-result/2;}if(!dense){topResult+=scale<1?Math.min(offset/2,refFontSize*scale):Math.min(result,refFontSize*scale)-offset/2;}}topResult=Math.floor(topResult);}else{if(height){return{paddingTop:Math.max(0,(height-fontSize)/2),paddingBottom:Math.max(0,(height-fontSize)/2)};}if(!isAndroid){if(dense){result+=scale<1?Math.min(offset/2,fontSize/2*scale):Math.min(offset/2,scale);}if(!dense){result+=scale<1?Math.min(offset,fontSize*scale):Math.min(fontSize,offset/2*scale);}result=Math.floor(result);topResult=result;bottomResult=result;}}return{paddingTop:Math.max(0,topResult),paddingBottom:Math.max(0,bottomResult)};};export var interpolatePlaceholder=function interpolatePlaceholder(labeled,hasActiveOutline){return labeled.interpolate({inputRange:[0,1],outputRange:[hasActiveOutline?0:1,1]});};export function calculateFlatAffixTopPosition(_ref4){var height=_ref4.height,paddingTop=_ref4.paddingTop,paddingBottom=_ref4.paddingBottom,affixHeight=_ref4.affixHeight;var inputHeightWithoutPadding=height-paddingTop-paddingBottom;var halfOfTheInputHeightDecreasedByAffixHeight=(inputHeightWithoutPadding-affixHeight)/2;return paddingTop+halfOfTheInputHeightDecreasedByAffixHeight;}export function calculateOutlinedIconAndAffixTopPosition(_ref5){var height=_ref5.height,affixHeight=_ref5.affixHeight,labelYOffset=_ref5.labelYOffset;return(height-affixHeight+labelYOffset)/2;}export var calculateFlatInputHorizontalPadding=function calculateFlatInputHorizontalPadding(_ref6){var adornmentConfig=_ref6.adornmentConfig;var paddingLeft=LABEL_PADDING_HORIZONTAL;var paddingRight=LABEL_PADDING_HORIZONTAL;adornmentConfig.forEach(function(_ref7){var type=_ref7.type,side=_ref7.side;if(type===AdornmentType.Icon&&side===AdornmentSide.Left){paddingLeft=ADORNMENT_SIZE+ADORNMENT_OFFSET+FLAT_INPUT_OFFSET;}else if(side===AdornmentSide.Right){if(type===AdornmentType.Affix){paddingRight=ADORNMENT_SIZE+ADORNMENT_OFFSET+FLAT_INPUT_OFFSET;}else if(type===AdornmentType.Icon){paddingRight=ADORNMENT_SIZE+ADORNMENT_OFFSET+FLAT_INPUT_OFFSET;}}});return{paddingLeft:paddingLeft,paddingRight:paddingRight};};export function areLabelsEqual(label1,label2){if(label1===label2){return true;}if(!(label1||label2)){return true;}if(!(label1&&label2)){return false;}if(typeof label1!==typeof label2){return false;}if(typeof label1==='string'||label1 instanceof String||typeof label2==='string'||label2 instanceof String){return false;}if(label1.type!==label2.type){return false;}var label1Props=label1.props||{};var label2Props=label2.props||{};if(JSON.stringify(label1Props)!==JSON.stringify(label2Props)){return false;}if(!(label1Props.children||label2Props.children)){return true;}if(!(label1Props.children&&label2Props.children)){return false;}var label1IsArray=Array.isArray(label1Props.children);var label2IsArray=Array.isArray(label2Props.children);if(label1IsArray&&label2IsArray){var children1=label1Props.children;var children2=label2Props.children;if(children1.length!==children2.length){return false;}for(var i=0;i<children1.length;i++){if(!areLabelsEqual(children1[i],children2[i])){return false;}}return true;}if(label1IsArray||label2IsArray){return false;}return areLabelsEqual(label1Props.children,label2Props.children);}","map":{"version":3,"sources":["helpers.tsx"],"names":["calculateLabelTopPosition","height","optionalPadding","customHeight","Math","calculateInputHeight","finalHeight","calculatePadding","props","multiline","result","calculateTextAreaPadding","calculateInputPadding","dense","isAndroid","refFontSize","scale","topPosition","offset","adjustPaddingOut","fontHeight","lineHeight","refFontHeight","paddingTop","paddingBottom","adjustPaddingFlat","styles","topResult","bottomResult","fontSize","interpolatePlaceholder","inputRange","outputRange","hasActiveOutline","affixHeight","inputHeightWithoutPadding","halfOfTheInputHeightDecreasedByAffixHeight","labelYOffset","calculateFlatInputHorizontalPadding","adornmentConfig","paddingLeft","paddingRight","side","type","AdornmentType","AdornmentSide","ADORNMENT_SIZE","label1","label2","label1Props","label2Props","JSON","label1IsArray","Array","label2IsArray","children1","children2","i","areLabelsEqual"],"mappings":"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","sourcesContent":["import type { Animated } from 'react-native';\nimport type { AdornmentConfig } from './Adornment/types';\nimport {\n  LABEL_PADDING_HORIZONTAL,\n  ADORNMENT_OFFSET,\n  ADORNMENT_SIZE,\n  FLAT_INPUT_OFFSET,\n} from './constants';\nimport { AdornmentType, AdornmentSide } from './Adornment/enums';\nimport type { TextInputLabelProp } from './types';\n\ntype PaddingProps = {\n  height: number | null;\n  labelHalfHeight: number;\n  multiline: boolean | null;\n  dense: boolean | null;\n  topPosition: number;\n  fontSize: number;\n  lineHeight?: number;\n  label?: TextInputLabelProp | null;\n  scale: number;\n  offset: number;\n  isAndroid: boolean;\n  styles: { paddingTop: number; paddingBottom: number };\n};\n\ntype AdjProps = PaddingProps & {\n  pad: number;\n};\n\nexport type Padding = { paddingTop: number; paddingBottom: number };\n\nexport const calculateLabelTopPosition = (\n  labelHeight: number,\n  height: number = 0,\n  optionalPadding: number = 0\n): number => {\n  const customHeight = height > 0 ? height : 0;\n\n  return Math.floor((customHeight - labelHeight) / 2 + optionalPadding);\n};\n\nexport const calculateInputHeight = (\n  labelHeight: number,\n  height: any = 0,\n  minHeight: number\n): number => {\n  const finalHeight = height > 0 ? height : labelHeight;\n\n  if (height > 0) return height;\n  return finalHeight < minHeight ? minHeight : finalHeight;\n};\n\nexport const calculatePadding = (props: PaddingProps): number => {\n  const { height, multiline = false } = props;\n\n  let result = 0;\n\n  if (multiline) {\n    if (height && multiline) {\n      result = calculateTextAreaPadding(props);\n    } else {\n      result = calculateInputPadding(props);\n    }\n  }\n\n  return Math.max(0, result);\n};\n\nconst calculateTextAreaPadding = (props: PaddingProps) => {\n  const { dense } = props;\n\n  return dense ? 10 : 20;\n};\n\nconst calculateInputPadding = ({\n  topPosition,\n  fontSize,\n  multiline,\n  scale,\n  dense,\n  offset,\n  isAndroid,\n}: PaddingProps): number => {\n  const refFontSize = scale * fontSize;\n  let result = Math.floor(topPosition / 2);\n\n  result =\n    result +\n    Math.floor((refFontSize - fontSize) / 2) -\n    (scale < 1 ? offset / 2 : 0);\n\n  if (multiline && isAndroid)\n    result = Math.min(dense ? offset / 2 : offset, result);\n\n  return result;\n};\n\nexport const adjustPaddingOut = ({\n  pad,\n  multiline,\n  label,\n  scale,\n  height,\n  fontSize,\n  lineHeight,\n  dense,\n  offset,\n  isAndroid,\n}: AdjProps): Padding => {\n  const fontHeight = lineHeight ?? fontSize;\n  const refFontHeight = scale * fontSize;\n  let result = pad;\n\n  if (height && !multiline) {\n    return {\n      paddingTop: Math.max(0, (height - fontHeight) / 2),\n      paddingBottom: Math.max(0, (height - fontHeight) / 2),\n    };\n  }\n  if (!isAndroid && multiline) {\n    if (dense) {\n      if (label) {\n        result += scale < 1 ? Math.min(offset, (refFontHeight / 2) * scale) : 0;\n      } else {\n        result += 0;\n      }\n    }\n    if (!dense) {\n      if (label) {\n        result +=\n          scale < 1\n            ? Math.min(offset, refFontHeight * scale)\n            : Math.min(offset / 2, refFontHeight * scale);\n      } else {\n        result += scale < 1 ? Math.min(offset / 2, refFontHeight * scale) : 0;\n      }\n    }\n    result = Math.floor(result);\n  }\n  return { paddingTop: result, paddingBottom: result };\n};\n\nexport const adjustPaddingFlat = ({\n  pad,\n  scale,\n  multiline,\n  label,\n  height,\n  offset,\n  dense,\n  fontSize,\n  isAndroid,\n  styles,\n}: AdjProps): Padding => {\n  let result = pad;\n  let topResult = result;\n  let bottomResult = result;\n  const { paddingTop, paddingBottom } = styles;\n  const refFontSize = scale * fontSize;\n\n  if (!multiline) {\n    // do not modify padding if input is not multiline\n    if (label) {\n      // return const style for flat input with label\n      return { paddingTop, paddingBottom };\n    }\n    // return pad for flat input without label\n    return { paddingTop: result, paddingBottom: result };\n  }\n\n  if (label) {\n    // add paddings passed from styles\n    topResult = paddingTop;\n    bottomResult = paddingBottom;\n\n    // adjust top padding for iOS\n    if (!isAndroid) {\n      if (dense) {\n        topResult +=\n          scale < 1\n            ? Math.min(result, refFontSize * scale) - result / 2\n            : Math.min(result, refFontSize * scale) - result / 2;\n      }\n      if (!dense) {\n        topResult +=\n          scale < 1\n            ? Math.min(offset / 2, refFontSize * scale)\n            : Math.min(result, refFontSize * scale) - offset / 2;\n      }\n    }\n    topResult = Math.floor(topResult);\n  } else {\n    if (height) {\n      // center text when height is passed\n      return {\n        paddingTop: Math.max(0, (height - fontSize) / 2),\n        paddingBottom: Math.max(0, (height - fontSize) / 2),\n      };\n    }\n    // adjust paddings for iOS if no label\n    if (!isAndroid) {\n      if (dense) {\n        result +=\n          scale < 1\n            ? Math.min(offset / 2, (fontSize / 2) * scale)\n            : Math.min(offset / 2, scale);\n      }\n      if (!dense) {\n        result +=\n          scale < 1\n            ? Math.min(offset, fontSize * scale)\n            : Math.min(fontSize, (offset / 2) * scale);\n      }\n\n      result = Math.floor(result);\n      topResult = result;\n      bottomResult = result;\n    }\n  }\n\n  return {\n    paddingTop: Math.max(0, topResult),\n    paddingBottom: Math.max(0, bottomResult),\n  };\n};\n\nexport const interpolatePlaceholder = (\n  labeled: Animated.Value,\n  hasActiveOutline: boolean | undefined\n) =>\n  labeled.interpolate({\n    inputRange: [0, 1],\n    outputRange: [hasActiveOutline ? 0 : 1, 1],\n  });\n\nexport function calculateFlatAffixTopPosition({\n  height,\n  paddingTop,\n  paddingBottom,\n  affixHeight,\n}: {\n  height: number;\n  paddingTop: number;\n  paddingBottom: number;\n  affixHeight: number;\n}): number {\n  const inputHeightWithoutPadding = height - paddingTop - paddingBottom;\n\n  const halfOfTheInputHeightDecreasedByAffixHeight =\n    (inputHeightWithoutPadding - affixHeight) / 2;\n\n  return paddingTop + halfOfTheInputHeightDecreasedByAffixHeight;\n}\n\nexport function calculateOutlinedIconAndAffixTopPosition({\n  height,\n  affixHeight,\n  labelYOffset,\n}: {\n  height: number;\n  affixHeight: number;\n  labelYOffset: number;\n}): number {\n  return (height - affixHeight + labelYOffset) / 2;\n}\n\nexport const calculateFlatInputHorizontalPadding = ({\n  adornmentConfig,\n}: {\n  adornmentConfig: AdornmentConfig[];\n}) => {\n  let paddingLeft = LABEL_PADDING_HORIZONTAL;\n  let paddingRight = LABEL_PADDING_HORIZONTAL;\n\n  adornmentConfig.forEach(({ type, side }) => {\n    if (type === AdornmentType.Icon && side === AdornmentSide.Left) {\n      paddingLeft = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n    } else if (side === AdornmentSide.Right) {\n      if (type === AdornmentType.Affix) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      } else if (type === AdornmentType.Icon) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      }\n    }\n  });\n\n  return { paddingLeft, paddingRight };\n};\n\nexport function areLabelsEqual(\n  label1?: TextInputLabelProp,\n  label2?: TextInputLabelProp\n): boolean {\n  if (label1 === label2) {\n    // will also take care of equality for `string` type, or if both are undefined.\n    return true;\n  }\n\n  // Return true if both of them are falsy.\n  if (!(label1 || label2)) {\n    return true;\n  }\n\n  // At this point, both of them cannot be false.\n  // So, return false if any of them is falsy.\n  if (!(label1 && label2)) {\n    return false;\n  }\n\n  // At this point, both of them has to be truthy.\n  // So, return false if they are not of the same type.\n  if (typeof label1 !== typeof label2) {\n    return false;\n  }\n\n  // At this point, both of them has to be of the same datatype.\n  if (\n    typeof label1 === 'string' ||\n    label1 instanceof String ||\n    // These last two OR checks are only here for Typescript's sake.\n    typeof label2 === 'string' ||\n    label2 instanceof String\n  ) {\n    // They're strings, so they won't be equal; otherwise\n    //  we would have returned 'true' earlier.\n    return false;\n  }\n\n  // At this point, both of them has to be of the datatype: `React.ReactElement`.\n  if (label1.type !== label2.type) {\n    return false;\n  }\n\n  // Preliminary equality check: do they stringify to the same string?\n  const label1Props = label1.props || {};\n  const label2Props = label2.props || {};\n  if (JSON.stringify(label1Props) !== JSON.stringify(label2Props)) {\n    return false;\n  }\n\n  // We now know they stringify to the same string.\n  // Return true if both of them DO NOT have children\n  if (!(label1Props.children || label2Props.children)) {\n    return true; // since there's nothing else to check\n  }\n\n  // Return false if only one of them has children\n  if (!(label1Props.children && label2Props.children)) {\n    return false;\n  }\n\n  // Both have children...\n  // Handle for when both the children are arrays\n  const label1IsArray = Array.isArray(label1Props.children);\n  const label2IsArray = Array.isArray(label2Props.children);\n  if (label1IsArray && label2IsArray) {\n    const children1 = label1Props.children as any[];\n    const children2 = label2Props.children as any[];\n    if (children1.length !== children2.length) {\n      return false; // no point proceeding\n    }\n\n    // all the children must also be equal\n    for (let i = 0; i < children1.length; i++) {\n      if (!areLabelsEqual(children1[i], children2[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // Only one of them can be an array at this point. If any is array, return false\n  if (label1IsArray || label2IsArray) {\n    return false;\n  }\n\n  // both children are not arrays, so recur.\n  return areLabelsEqual(label1Props.children, label2Props.children);\n}\n"]},"metadata":{},"sourceType":"module"}